"""Implementation of the workbench service."""

from typing import List, Dict, Any, Optional
import re

from ..abstractions.service_interfaces import (
    IWorkbenchService,
    WorkbenchContext,
    OperationResult,
    OperationType
)
from ..abstractions.uow import IUnitOfWork


class WorkbenchService(IWorkbenchService):
    """Service implementation for workbench operations."""
    
    async def validate_operation(
        self,
        context: WorkbenchContext,
        uow: IUnitOfWork
    ) -> List[str]:
        """Validate the operation can be performed."""
        errors = []
        
        # Common validations
        if not context.source_datasets:
            errors.append("At least one source dataset is required")
        
        if context.operation_type == OperationType.SQL_TRANSFORM:
            # SQL-specific validations
            sql = context.parameters.get("sql", "").strip()
            if not sql:
                errors.append("SQL query is required")
            
            # Basic SQL injection prevention (simplified)
            dangerous_patterns = [
                r";\s*DROP\s+",
                r";\s*DELETE\s+FROM\s+dsa_",
                r";\s*TRUNCATE\s+",
                r";\s*ALTER\s+",
                r";\s*CREATE\s+USER",
                r";\s*GRANT\s+"
            ]
            
            for pattern in dangerous_patterns:
                if re.search(pattern, sql, re.IGNORECASE):
                    errors.append(f"SQL contains potentially dangerous statement: {pattern}")
            
            # Validate sources
            sources = context.parameters.get("sources", [])
            if not sources:
                errors.append("At least one source table is required")
            
            # Check for duplicate aliases
            aliases = [s.get("alias") for s in sources]
            if len(aliases) != len(set(aliases)):
                errors.append("Source aliases must be unique")
        
        return errors
    
    async def preview_operation(
        self,
        context: WorkbenchContext,
        uow: IUnitOfWork,
        sample_size: int = 100
    ) -> Dict[str, Any]:
        """Preview the operation results without executing."""
        # For SQL_TRANSFORM, this would be handled by the handler itself
        # This is a simplified implementation
        if context.operation_type == OperationType.SQL_TRANSFORM:
            return {
                "preview_available": True,
                "sample_size": sample_size,
                "operation_type": context.operation_type.value,
                "message": "Preview will be generated by SQL handler"
            }
        
        # Other operation types would have their own preview logic
        return {
            "preview_available": False,
            "operation_type": context.operation_type.value,
            "message": "Preview not implemented for this operation type"
        }
    
    async def execute_operation(
        self,
        context: WorkbenchContext,
        uow: IUnitOfWork
    ) -> OperationResult:
        """Execute the workbench operation."""
        # For SQL_TRANSFORM, execution happens through job system
        # This method would coordinate the execution for other operation types
        
        if context.operation_type == OperationType.SQL_TRANSFORM:
            # SQL transforms are handled asynchronously via jobs
            return OperationResult(
                success=True,
                operation_id=f"{context.operation_type.value}_{context.user_id}",
                error_message="SQL transforms must be executed via job system"
            )
        
        # Implement other operation types here
        return OperationResult(
            success=False,
            operation_id=f"{context.operation_type.value}_{context.user_id}",
            error_message=f"Operation type {context.operation_type.value} not implemented"
        )
    
    def list_available_operations(self) -> List[OperationType]:
        """List all available operation types."""
        return list(OperationType)